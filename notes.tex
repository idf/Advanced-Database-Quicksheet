%&latex
\documentclass{article}
\usepackage{commons/commons}
\usepackage{commons/note_style}

\usepackage{amssymb}

\def\ojoin{\setbox0=\hbox{$\bowtie$}%
  \rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}
\def\leftouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie}}
\def\rightouterjoin{\mathbin{\bowtie\mkern-5.8mu\ojoin}}
\def\fullouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie\mkern-5.8mu\ojoin}}

\begin{document}

%+Title
\title{Advanced Database Quicksheet}
\author{Daniel D. Zhang}
\date{Fall 2015}
\maketitle
%-Title

%+Abstract
%\begin{abstract}
%This is the notes for CSE 232A.
%\end{abstract}
%-Abstract

%+Contents
\tableofcontents
%-Contents
\newpage

\section{Introduction}
\begin{itemize}
\item Basic SQLs 
\item \rih{ACID}: Atomicity, Consistency, Isolation, Durability 
\begin{enumerate}
\item Atomicity: each transaction be "all or nothing".
\item Consistency: any transaction will bring the database from one valid state to
another.
\item Isolation: the concurrent execution of transactions results in a system state
that would be obtained if transactions were executed serially
\item Durability: once a transaction has been committed, it will remain so, even in
the event of power loss, crashes, or 
\end{enumerate}
\item Transaction Mgt
\item Database System Architecture. Fig TODOf
\end{itemize}


\section{Hardware}
\begin{itemize}
\item Memory Hierarchy 
\begin{enumerate}
\item Blocked-based access 
\item Different Rates of Improvement 
\end{enumerate}
\item Tuned for blocks: Two-Phase, Multiway MergeSort (TPMMS). 
\begin{enumerate}
\item Phase 1: Load and sort into multiple lists 
\item Phase 2: Merge multiple lists 

Upper data size: 
$$
\frac{M^2}{B}
$$
, where $M\trieq$ RAM size, $B\trieq$ block size. 
\end{enumerate}
\end{itemize}


\section{Indexing}
\subsection{B+Tree}
\begin{tabular}{lll}
\hline\noalign{\smallskip}
\textbf{Attrs} & \textbf{Non-leaf} & \textbf{Leaf} \\
\noalign{\smallskip}\hline\noalign{\smallskip}
Ptrs & \lceil\frac{n+1}{2}\rceil & \lfloor\frac{n+1}{2}\rfloor \\
\noalign{\smallskip}\hline\noalign{\
\caption{Nodes at least half-full}
\end{tabular}

\section{Query Processing}
\subsection{Relational algebra}
Notations:
\begin{enumerate}
\item $\sigma$: Filter, WHERE (conditions)
\item $\times$: Cartesian, FROM product 
\item $\Pi$: Projection, SELECT (attributes)
\item $x\ra y$: Rename $x$ to $y$. Scalar func: $a+b\ra y$, String ops: $c||d \ra y$

Scalar functions: their input comes from the same tuple (as opp. aggregate)
$$
\Pi_{x, y\ra z, x+y\ra w} R
$$
$PLUS_{x, y\ra z}$, $CONCAT_{x,y\ra z}$
\item $\bowtie$: Natural join: $R\bowtiewS = \Pi_A\sigma_C(R\times S)$. Notice that the $\times$ is \textbf{bag} version. 

$\bowtie_{\theta}$: $\triangleq \sigma_{\theta} (R\times S)$. $\theta$ is a condition. \item $\gamma$: Group and aggregation 
$$
\gamma_{attr_{grpby}, aggr(attr) \ra attr'}
$$
\item $\tau$: Order by 

$\sigma$ may retain the order generated by $\tau$ but depends on implementation. e.g. $\sigma^{FLY}$

$$
\tau_{R.A, R.B} \sigma_{R.B>5}^{FLY} R
$$
produces a list
$$
\sigma^{FLY}_{R.B>5} \tau_{R.A, R.B} R 
$$
produces a bag but preserves the order. 
\end{enumerate}
\subsection{Query Plan}
A simple SFW (Select From Where). 
\begin{enumerate}
\item Naive plan:
$$
\Pi_{attr_1,attr_2}^{FLY}\Big[\sigma_{cond_1\wedge cond_2}^{FLY} (R^{SCAN}\times S^{SCAN})\Big]
$$

FLY and SCAN are how exactly the plan is run. 

\item Join Plan:
$$
\Pi_{attrs} \Big[(\sigma_{cond_1}R)  \bowtie^{HASH} (\sigma_{cond_2}S) \Big]
$$
\item Index plan:

$$
\Pi_{attrs}\sigma_{cond_2}(\sigma_{cond_1}^{INDEX}R \bowtie^{RI} S)
$$
$\bowtie^{RI}$ Right Index Join. 

\end{enumerate}
Complex
\begin{itemize}
\item Nested SQL algebra: see notes for rewriting. Essentially, convert nested SQL to JOIN.
\end{itemize}

\subsection{Bag}
In this nodes, bag-version operations are assumed. 
\begin{enumerate}
\item Algebraic Operators (Bag Version) $\cup, \cap$
$$
R\cup S
$$
\item Convert to set (DISTINCT)
$$
\delta(R)
$$
\end{enumerate}
\subsection{Relational algebra optimization}
\rih{Commutativity and Associativity}
\begin{align*}
R \cdot S &= S\cdot R \\
R\cdot (S\cdot T) &= (R\cdot S) \cdot T \\
\end{align}

, where $o \in \{\times, \bowtie, \cup, \cap \}$  

proof: $R\times S = S\times R$
\begin{align*}
& R \times S \subset S \times R \\
& R \times S \supset S \times R \\
& \forall t, t\in R\times S,\mbox{ n times} \\
& r \in R\mbox{ m times}, s\in S \mbox{ k times}\\
& n = m*k \\
& \Ra\mbox{ find corresponding }t \in sr, k*m,\mbox{ n times} \\ 
& \therefore R \times S \subset S \times R \\
& \mbox{vice versa...}
\end{align*}
\rih{Logics}
\begin{align*}
\sigma_{cond_1\wedge cond_2} \\
\sigma_{cond_1\vee cond_2}
\end{align*}

Notice that $\vee$ only applies for set-version\\
\rih{Push down} !important
$$
\sigma_{cond}(RoS) = (\sigma_{cond} R) o (\sigma_{cond} S) 

, where $o\in \{\times, \bowtie\}$. It can further drops the $\sigma_{cond}R$ to $R$ if the condition does not refer to attributes in R.

proof: $\sigma_{A=2}(R\bowtie S) = (\sigma_{A=2}R)\bowtie S$, given commutativity and $\sigma_{cond}(R\bowtie S) = R\bowtie \sigma_{cond}S$
\begin{align*}
\sigma_{A=2}(R\bowtie S) = \sigma_{A=2}(S\bowtie R) = S \bowtie (\sigma_{A=2}R)=(\sigma_{A=2}R\bowtie S)
\end{align*}

This is a technique of proof by using axioms. 
\section*{Acronyms}
\
\begin{obeylines}
\rih{Attr}. Attributes 
\rih{Ptr}. Pointer
\rih{Mgt}. Management 
\end{obeylines}


%+Bibliography
\begin{thebibliography}{99}
\bibitem{Label1} ...
\bibitem{Label2} ...
\end{thebibliography}
%-Bibliography
\end{document}
